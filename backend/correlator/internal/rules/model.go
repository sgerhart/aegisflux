package rules

import "fmt"


// Selector defines which hosts/events this rule applies to
type Selector struct {
	HostIDs        []string `yaml:"host_ids" json:"host_ids"`
	HostGlobs      []string `yaml:"host_globs" json:"host_globs"`
	Labels         []string `yaml:"labels" json:"labels"`
	ExcludeHostIDs []string `yaml:"exclude_host_ids" json:"exclude_host_ids"`
	// Enhanced host selection
	HostPatterns   []string `yaml:"host_patterns" json:"host_patterns"`   // Regex patterns for host matching
	Environment    []string `yaml:"environment" json:"environment"`       // Environment tags
	ServiceTypes   []string `yaml:"service_types" json:"service_types"`   // Service type tags
	Regions        []string `yaml:"regions" json:"regions"`               // Geographic regions
}

// EventPattern defines a pattern to match events
type EventPattern struct {
	EventType        string            `yaml:"event_type" json:"event_type"`
	BinaryPathRegex  string            `yaml:"binary_path_regex" json:"binary_path_regex"`
	Args             map[string]string `yaml:"args" json:"args"`
	Context          map[string]string `yaml:"context" json:"context"`
}

// Condition defines when a rule should trigger
type Condition struct {
	WindowSeconds int                     `yaml:"window_seconds" json:"window_seconds"`
	When          map[string]interface{}  `yaml:"when" json:"when"`
	RequiresPrior map[string]interface{}  `yaml:"requires_prior" json:"requires_prior"`
	// Enhanced temporal window support
	TemporalWindow *TemporalWindow        `yaml:"temporal_window" json:"temporal_window"`
	TimeRange      *TimeRange             `yaml:"time_range" json:"time_range"`
	Frequency      *Frequency             `yaml:"frequency" json:"frequency"`
}

// TemporalWindow defines a sliding time window for event correlation
type TemporalWindow struct {
	DurationSeconds int    `yaml:"duration_seconds" json:"duration_seconds"`
	StepSeconds     int    `yaml:"step_seconds" json:"step_seconds"`     // How often to evaluate
	OverlapAllowed  bool   `yaml:"overlap_allowed" json:"overlap_allowed"`
	WindowType      string `yaml:"window_type" json:"window_type"`       // "sliding", "tumbling", "session"
}

// TimeRange defines a specific time range for rule evaluation
type TimeRange struct {
	StartHour int `yaml:"start_hour" json:"start_hour"` // 0-23
	EndHour   int `yaml:"end_hour" json:"end_hour"`     // 0-23
	Days      []string `yaml:"days" json:"days"`        // ["monday", "tuesday", etc.]
	Timezone  string `yaml:"timezone" json:"timezone"`  // IANA timezone
}

// Frequency defines how often a rule should be evaluated
type Frequency struct {
	MinIntervalSeconds int `yaml:"min_interval_seconds" json:"min_interval_seconds"`
	MaxIntervalSeconds int `yaml:"max_interval_seconds" json:"max_interval_seconds"`
	BackoffMultiplier  float64 `yaml:"backoff_multiplier" json:"backoff_multiplier"`
}

// Outcome defines what happens when a rule triggers
type Outcome struct {
	Severity   string   `yaml:"severity" json:"severity"`
	Confidence float64  `yaml:"confidence" json:"confidence"`
	Evidence   []string `yaml:"evidence" json:"evidence"`
	// Enhanced outcome support
	Title       string            `yaml:"title" json:"title"`
	Description string            `yaml:"description" json:"description"`
	Tags        []string          `yaml:"tags" json:"tags"`
	Metadata    map[string]interface{} `yaml:"metadata" json:"metadata"`
	Actions     []Action          `yaml:"actions" json:"actions"`
}

// Action defines an action to take when a rule triggers
type Action struct {
	Type        string            `yaml:"type" json:"type"`               // "alert", "block", "log", "webhook"
	Parameters  map[string]interface{} `yaml:"parameters" json:"parameters"`
	Priority    int               `yaml:"priority" json:"priority"`
	Enabled     bool              `yaml:"enabled" json:"enabled"`
}

// Finding represents a security finding generated by a rule
type Finding struct {
	ID          string                 `json:"id"`
	HostID      string                 `json:"host_id"`
	Severity    string                 `json:"severity"`
	Type        string                 `json:"type"`
	Evidence    map[string]interface{} `json:"evidence"`
	TS          string                 `json:"ts"`
	// Enhanced finding fields
	RuleID      string                 `json:"rule_id"`
	RuleName    string                 `json:"rule_name"`
	Confidence  float64                `json:"confidence"`
	Title       string                 `json:"title"`
	Description string                 `json:"description"`
	Tags        []string               `json:"tags"`
	Metadata    map[string]interface{} `json:"metadata"`
	Actions     []Action               `json:"actions"`
	// Correlation context
	CorrelationID string               `json:"correlation_id"`
	SourceEvents  []string             `json:"source_events"`
	WindowStart   string               `json:"window_start"`
	WindowEnd     string               `json:"window_end"`
}

// Dedupe defines deduplication settings for findings
type Dedupe struct {
	KeyTemplate     string `yaml:"key_template" json:"key_template"`
	CooldownSeconds int    `yaml:"cooldown_seconds" json:"cooldown_seconds"`
}

// RuleMetadata contains metadata about a rule
type RuleMetadata struct {
	ID      string `yaml:"id" json:"id"`
	Name    string `yaml:"name" json:"name"`
	Version string `yaml:"version" json:"version"`
}

// RuleSpec contains the rule specification
type RuleSpec struct {
	Enabled    bool      `yaml:"enabled" json:"enabled"`
	Selectors  Selector  `yaml:"selectors" json:"selectors"`
	Condition  Condition `yaml:"condition" json:"condition"`
	Outcome    Outcome   `yaml:"outcome" json:"outcome"`
	Dedupe     Dedupe    `yaml:"dedupe" json:"dedupe"`
	TTLSeconds int       `yaml:"ttl_seconds" json:"ttl_seconds"`
}

// Rule represents a complete correlation rule
type Rule struct {
	APIVersion string       `yaml:"apiVersion" json:"apiVersion"`
	Kind       string       `yaml:"kind" json:"kind"`
	Metadata   RuleMetadata `yaml:"metadata" json:"metadata"`
	Spec       RuleSpec     `yaml:"spec" json:"spec"`
	SourceFile string       `json:"source_file"` // Internal field for tracking source
}

// RuleSnapshot represents a collection of loaded rules
type RuleSnapshot struct {
	Rules   []Rule
	Version int64 // Timestamp when snapshot was created
}

// Validate checks if a rule is valid
func (r *Rule) Validate() error {
	// Check required fields
	if r.Metadata.ID == "" {
		return &ValidationError{Field: "metadata.id", Message: "rule ID is required"}
	}
	
	if r.Metadata.Name == "" {
		return &ValidationError{Field: "metadata.name", Message: "rule name is required"}
	}
	
	if r.Spec.Outcome.Severity == "" {
		return &ValidationError{Field: "spec.outcome.severity", Message: "severity is required"}
	}
	
	// Validate severity values
	validSeverities := map[string]bool{
		"low": true, "medium": true, "high": true, "critical": true,
	}
	if !validSeverities[r.Spec.Outcome.Severity] {
		return &ValidationError{Field: "spec.outcome.severity", Message: "invalid severity, must be low/medium/high/critical"}
	}
	
	// Validate confidence range
	if r.Spec.Outcome.Confidence < 0.0 || r.Spec.Outcome.Confidence > 1.0 {
		return &ValidationError{Field: "spec.outcome.confidence", Message: "confidence must be between 0.0 and 1.0"}
	}
	
	// Validate TTL
	if r.Spec.TTLSeconds <= 0 {
		return &ValidationError{Field: "spec.ttl_seconds", Message: "TTL must be positive"}
	}
	
	return nil
}

// IsEnabled checks if the rule is enabled
func (r *Rule) IsEnabled() bool {
	return r.Spec.Enabled
}

// ValidationError represents a rule validation error
type ValidationError struct {
	Field   string
	Message string
}

func (e *ValidationError) Error() string {
	return e.Field + ": " + e.Message
}

// ValidateTemporalWindow validates a temporal window configuration
func (tw *TemporalWindow) Validate() error {
	if tw.DurationSeconds <= 0 {
		return &ValidationError{Field: "temporal_window.duration_seconds", Message: "duration must be positive"}
	}
	if tw.StepSeconds <= 0 {
		return &ValidationError{Field: "temporal_window.step_seconds", Message: "step must be positive"}
	}
	if tw.StepSeconds > tw.DurationSeconds {
		return &ValidationError{Field: "temporal_window.step_seconds", Message: "step cannot be greater than duration"}
	}
	
	validWindowTypes := map[string]bool{
		"sliding": true, "tumbling": true, "session": true,
	}
	if tw.WindowType != "" && !validWindowTypes[tw.WindowType] {
		return &ValidationError{Field: "temporal_window.window_type", Message: "invalid window type, must be sliding/tumbling/session"}
	}
	
	return nil
}

// ValidateTimeRange validates a time range configuration
func (tr *TimeRange) Validate() error {
	if tr.StartHour < 0 || tr.StartHour > 23 {
		return &ValidationError{Field: "time_range.start_hour", Message: "start hour must be between 0 and 23"}
	}
	if tr.EndHour < 0 || tr.EndHour > 23 {
		return &ValidationError{Field: "time_range.end_hour", Message: "end hour must be between 0 and 23"}
	}
	
	validDays := map[string]bool{
		"monday": true, "tuesday": true, "wednesday": true, "thursday": true,
		"friday": true, "saturday": true, "sunday": true,
	}
	for _, day := range tr.Days {
		if !validDays[day] {
			return &ValidationError{Field: "time_range.days", Message: "invalid day: " + day}
		}
	}
	
	return nil
}

// ValidateFrequency validates a frequency configuration
func (f *Frequency) Validate() error {
	if f.MinIntervalSeconds <= 0 {
		return &ValidationError{Field: "frequency.min_interval_seconds", Message: "min interval must be positive"}
	}
	if f.MaxIntervalSeconds <= 0 {
		return &ValidationError{Field: "frequency.max_interval_seconds", Message: "max interval must be positive"}
	}
	if f.MinIntervalSeconds > f.MaxIntervalSeconds {
		return &ValidationError{Field: "frequency.min_interval_seconds", Message: "min interval cannot be greater than max interval"}
	}
	if f.BackoffMultiplier < 1.0 {
		return &ValidationError{Field: "frequency.backoff_multiplier", Message: "backoff multiplier must be >= 1.0"}
	}
	
	return nil
}

// ValidateAction validates an action configuration
func (a *Action) Validate() error {
	if a.Type == "" {
		return &ValidationError{Field: "action.type", Message: "action type is required"}
	}
	
	validActionTypes := map[string]bool{
		"alert": true, "block": true, "log": true, "webhook": true, "email": true, "slack": true,
	}
	if !validActionTypes[a.Type] {
		return &ValidationError{Field: "action.type", Message: "invalid action type: " + a.Type}
	}
	
	if a.Priority < 0 {
		return &ValidationError{Field: "action.priority", Message: "priority must be non-negative"}
	}
	
	return nil
}

// ValidateFinding validates a finding
func (f *Finding) Validate() error {
	if f.ID == "" {
		return &ValidationError{Field: "finding.id", Message: "finding ID is required"}
	}
	if f.HostID == "" {
		return &ValidationError{Field: "finding.host_id", Message: "host ID is required"}
	}
	if f.Severity == "" {
		return &ValidationError{Field: "finding.severity", Message: "severity is required"}
	}
	if f.Type == "" {
		return &ValidationError{Field: "finding.type", Message: "type is required"}
	}
	if f.TS == "" {
		return &ValidationError{Field: "finding.ts", Message: "timestamp is required"}
	}
	
	validSeverities := map[string]bool{
		"info": true, "low": true, "medium": true, "high": true, "critical": true,
	}
	if !validSeverities[f.Severity] {
		return &ValidationError{Field: "finding.severity", Message: "invalid severity: " + f.Severity}
	}
	
	if f.Confidence < 0.0 || f.Confidence > 1.0 {
		return &ValidationError{Field: "finding.confidence", Message: "confidence must be between 0.0 and 1.0"}
	}
	
	// Validate actions
	for i, action := range f.Actions {
		if err := action.Validate(); err != nil {
			return &ValidationError{Field: fmt.Sprintf("finding.actions[%d]", i), Message: err.Error()}
		}
	}
	
	return nil
}
